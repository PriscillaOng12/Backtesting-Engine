"""
Event classes for the backtesting engine.

This module defines the event-driven architecture events that flow through
the backtesting system. Events are processed chronologically to simulate
real-time trading conditions.
"""

from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from typing import Any, Dict, Optional, Union, Literal
from decimal import Decimal

import pandas as pd
from pydantic import BaseModel, Field, field_validator, ConfigDict


class EventType(Enum):
    """Enumeration of event types in the backtesting system."""
    MARKET = "MARKET"
    SIGNAL = "SIGNAL"
    ORDER = "ORDER"
    FILL = "FILL"


class OrderType(Enum):
    """Enumeration of order types."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"


class OrderSide(Enum):
    """Enumeration of order sides."""
    BUY = "BUY"
    SELL = "SELL"


class OrderStatus(Enum):
    """Enumeration of order statuses."""
    PENDING = "PENDING"
    FILLED = "FILLED"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"


class Event(BaseModel, ABC):
    """
    Abstract base class for all events in the backtesting system.
    
    Attributes:
        event_type: The type of event
        timestamp: When the event occurred
        priority: Event priority for queue ordering (lower = higher priority)
    """
    event_type: EventType
    timestamp: datetime
    priority: int = Field(default=0, ge=0)
    
    model_config = ConfigDict(
        use_enum_values=True,
        arbitrary_types_allowed=True
    )
    
    def __lt__(self, other: 'Event') -> bool:
        """Enable priority queue ordering."""
        if self.priority != other.priority:
            return self.priority < other.priority
        return self.timestamp < other.timestamp


class MarketEvent(Event):
    """
    Market data event containing price and volume information.
    
    Attributes:
        symbol: Trading symbol
        open_price: Opening price
        high_price: High price
        low_price: Low price
        close_price: Closing price
        volume: Trading volume
        adj_close: Adjusted closing price (optional)
        dividend: Dividend amount (optional)
        split_ratio: Stock split ratio (optional)
    """
    event_type: Literal[EventType.MARKET] = Field(default=EventType.MARKET)
    symbol: str
    open_price: Decimal
    high_price: Decimal
    low_price: Decimal
    close_price: Decimal
    volume: int
    adj_close: Optional[Decimal] = None
    dividend: Optional[Decimal] = None
    split_ratio: Optional[Decimal] = None
    
    @field_validator('high_price')
    @classmethod
    def validate_high_price(cls, v, info):
        """Validate that high >= low, open, close."""
        values = info.data if info else {}
        if 'low_price' in values and v < values['low_price']:
            raise ValueError("High price cannot be less than low price")
        if 'open_price' in values and v < values['open_price']:
            raise ValueError("High price cannot be less than open price")
        if 'close_price' in values and v < values['close_price']:
            raise ValueError("High price cannot be less than close price")
        return v
    
    @field_validator('low_price')
    @classmethod
    def validate_low_price(cls, v, info):
        """Validate that low <= high, open, close."""
        values = info.data if info else {}
        if 'open_price' in values and v > values['open_price']:
            raise ValueError("Low price cannot be greater than open price")
        if 'close_price' in values and v > values['close_price']:
            raise ValueError("Low price cannot be greater than close price")
        return v
    
    @field_validator('volume')
    @classmethod
    def validate_volume(cls, v):
        """Validate that volume is non-negative."""
        if v < 0:
            raise ValueError("Volume cannot be negative")
        return v


class SignalEvent(Event):
    """
    Trading signal event generated by strategies.
    
    Attributes:
        strategy_id: Identifier of the strategy generating the signal
        symbol: Trading symbol
        signal_type: Type of signal (BUY/SELL)
        strength: Signal strength (0.0 to 1.0)
        target_percent: Target position as percentage of portfolio
        metadata: Additional signal metadata
    """
    event_type: Literal[EventType.SIGNAL] = Field(default=EventType.SIGNAL)
    priority: Literal[1] = Field(default=1)
    strategy_id: str
    symbol: str
    signal_type: OrderSide
    strength: float = Field(ge=0.0, le=1.0)
    target_percent: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    metadata: Dict[str, Any] = Field(default_factory=dict)


class OrderEvent(Event):
    """
    Order event representing a trading order.
    
    Attributes:
        order_id: Unique order identifier
        symbol: Trading symbol
        order_type: Type of order (MARKET, LIMIT, etc.)
        side: Order side (BUY/SELL)
        quantity: Number of shares/units
        price: Order price (None for market orders)
        stop_price: Stop price for stop orders
        time_in_force: Order time in force
        strategy_id: Strategy that generated the order
    """
    event_type: Literal[EventType.ORDER] = Field(default=EventType.ORDER)
    priority: Literal[2] = Field(default=2)
    order_id: str
    symbol: str
    order_type: OrderType
    side: OrderSide
    quantity: int = Field(gt=0)
    price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    time_in_force: str = Field(default="DAY")
    strategy_id: Optional[str] = None
    
    @field_validator('price')
    @classmethod
    def validate_price(cls, v, info):
        """Validate price for limit orders."""
        if v is not None and v <= 0:
            raise ValueError("Price must be positive")
        values = info.data if info else {}
        if values.get('order_type') == OrderType.LIMIT and v is None:
            raise ValueError("Limit orders must have a price")
        return v
    
    @field_validator('stop_price')
    @classmethod
    def validate_stop_price(cls, v, info):
        """Validate stop price for stop orders."""
        if v is not None and v <= 0:
            raise ValueError("Stop price must be positive")
        values = info.data if info else {}
        order_type = values.get('order_type')
        if order_type in [OrderType.STOP, OrderType.STOP_LIMIT] and v is None:
            raise ValueError("Stop orders must have a stop price")
        return v


class FillEvent(Event):
    """
    Order fill event representing a completed trade.
    
    Attributes:
        fill_id: Unique fill identifier
        order_id: Original order identifier
        symbol: Trading symbol
        side: Trade side (BUY/SELL)
        quantity: Number of shares filled
        fill_price: Actual fill price
        commission: Commission paid
        slippage: Slippage incurred
        timestamp: Fill timestamp
        exchange: Exchange where trade occurred
    """
    event_type: Literal[EventType.FILL] = Field(default=EventType.FILL)
    priority: Literal[3] = Field(default=3)
    fill_id: str
    order_id: str
    symbol: str
    side: OrderSide
    quantity: int = Field(gt=0)
    fill_price: Decimal = Field(gt=0)
    commission: Decimal = Field(ge=0)
    slippage: Decimal = Field(default=Decimal('0'))
    exchange: str = Field(default="DEFAULT")
    
    @property
    def gross_amount(self) -> Decimal:
        """Calculate gross trade amount."""
        return self.fill_price * self.quantity
    
    @property
    def net_amount(self) -> Decimal:
        """Calculate net trade amount after commission."""
        if self.side == OrderSide.BUY:
            return -(self.gross_amount + self.commission)
        else:
            return self.gross_amount - self.commission


class MarketDataSnapshot(BaseModel):
    """
    Current market data snapshot for multiple symbols.
    
    Attributes:
        timestamp: Snapshot timestamp
        data: Dictionary mapping symbols to their latest market data
    """
    timestamp: datetime
    data: Dict[str, MarketEvent]
    
    def get_price(self, symbol: str, price_type: str = "close") -> Optional[Decimal]:
        """
        Get the current price for a symbol.
        
        Args:
            symbol: Trading symbol
            price_type: Type of price (open, high, low, close, adj_close)
            
        Returns:
            Current price or None if symbol not found
        """
        if symbol not in self.data:
            return None
        
        market_event = self.data[symbol]
        price_map = {
            'open': market_event.open_price,
            'high': market_event.high_price,
            'low': market_event.low_price,
            'close': market_event.close_price,
            'adj_close': market_event.adj_close or market_event.close_price
        }
        
        return price_map.get(price_type, market_event.close_price)
    
    def get_volume(self, symbol: str) -> Optional[int]:
        """Get the current volume for a symbol."""
        if symbol not in self.data:
            return None
        return self.data[symbol].volume


# Type aliases for better code readability
EventQueue = list[Event]
SymbolPriceMap = Dict[str, Decimal]
